#!/usr/bin/env node
var request = require('request');
var getURLs = require('get-urls');

const MongoClient = require('mongodb').MongoClient;

MongoClient.connect('mongodb://heroku_p4kv17tq:s268pk2ssbk5hd3v3m5175nkfg@ds149069.mlab.com:49069/heroku_p4kv17tq', (err, db) => {
  if (err) return console.log(err)
  getData(db);
})

function getData(db) {
  var count = 0;

  var options = {
    url: '',
    headers: {
      'User-Agent': 'web:5Ku4NNXMzh5atA:v0.0.1 (by /u/jare_)'
    }
  };

  options['url'] = 'https://www.reddit.com/subreddits/popular.json?limit=100';
  request(options, function (error, response, body) {
    if (error) return console.log('Error getting subs: ', error);
    if (response.statusCode == 200) {
      var bodyJSON = JSON.parse(body);
      var data = bodyJSON.data.children;
      var subData = data.map(function(sub) { return {url: sub.data.url, name: sub.data.display_name} });
      subData.forEach(function(subDataElement) {
        let subURL = subDataElement.url;
        let subName = subDataElement.name;

        let subURLFormatted = `https://reddit.com${subURL}top.json?limit=100`;
        
        options['url'] = subURLFormatted;
        request(options, function(error, response, body) {
          if (error) return console.log('Error getting articles in sub: ', error);
          if (response.statusCode == 200) {
            var bodyJSON = JSON.parse(body);
            var data = bodyJSON.data.children;
            var articleIDs = data.map(function(article) { return article.data.id; });

            articleIDs.forEach(function(link, index, linkArr) {
              var articleCommentsURL = `https://reddit.com${subURL}comments/${link}.json?limit=100`;
              
              options['url'] = articleCommentsURL;
              request(articleCommentsURL, function(error, response, body) {
                
                try {
                  var data = JSON.parse(body);
                } catch (e) {
                  console.log('Error getting comments in article: ', articleCommentsURL);
                  return;
                }

                var comments = data.map(function(comment) { 
                  return comment.data.children;
                });

                var commentLinkData =  comments.map(function(comment) {
                    var commentLinkData = comment.map(function(commentData) {
                      if (!commentData.data.body) return [];
                      var urls = getURLs(commentData.data.body);

                      if (!urls) return [];

                      var linkData = [];
                      for (let url of urls) {
                        if (url.includes('reddit.com/r') || (!url.includes('.gif') && !url.includes('.gifv')) ) continue;
                        if (url.charAt(url.length - 1) == ')') {
                          url = url.slice(0, -1);
                        }

                        let linkDataElement = {
                          c_id: commentData.data.id,
                          url: url,
                          sub: commentData.data.subreddit
                        }

                        linkData.push(linkDataElement);
                      }

                      return linkData;
                      
                    });

                    return commentLinkData;
                });

                var commentLinkData = [].concat.apply([], commentLinkData);
                var commentLinkData = commentLinkData.filter(function(data) {
                  return (data.length > 0);
                });

                var linkData = [];
                for (let data of commentLinkData) {                  
                  if (data.length === 1) linkData.push(data[0]);
                  data.forEach(function(dataElement) {
                    linkData.push(dataElement);
                  });
                }

                if (linkData.length === 0) return;
                linkData.forEach(function(linkObject) {
                  
                  count++;
                  if (count > 50) {
                    return;
                  }

                  db.collection('links').update({"c_id": linkObject.c_id},{$set: {"url" : linkObject.url,"sub" : linkObject.sub}},{upsert:true});

                });

              });

            });
          }
        });
      });
    }
  });
}